"""
Use Pyatoa to generate misfit windows for data gathered by PySEP and synthetics
generated by SPECFEM3D. For Yuan's SSA Tomography 2022 presentatation involving
synthetics through a basin
"""
import os
import shutil
import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np
from glob import glob
from obspy import read, UTCDateTime, Stream, read_events
from pyatoa import Config, Manager, logger

from pyatoa.utils.process import remove_zero_pad
from pyatoa.utils.read import read_sem
from pyflex import logger as pflogger

# Do not show GUI, otherwise script will hang trying to open a GUI window
mpl.use("Agg")

pflogger.setLevel("CRITICAL")
# logger.setLevel("CRITICAL")

# pflogger.setLevel("DEBUG")
logger.setLevel("DEBUG")

# >>> CHANGE YOUR PATHS HERE
path_to_synthetics = "./syn"
path_to_data = "./data"
path_to_figures = "./figures"
path_to_adjsrcs = "./adjsrcs"

for path_ in [path_to_figures, path_to_adjsrcs]:
    if os.path.exists(path_):
        shutil.rmtree(path_)
    os.makedirs(path_)


# >>> EDIT PARAMETERS HERE
event = read_events("event.xml")[0]
origintime = event.preferred_origin().time

start_pad = 100
end_wl = start_pad + 50
stalta_waterlevel = 0.05

cfg = Config(
        event_id="2018-10-03T032937_CENTRAL_ALASKA",
        cfgpaths={"waveforms": [path_to_data],
                  "synthetics": [path_to_synthetics]},

        # vvvv Pyatoa filtering parameters vvvv
        min_period=4,
        max_period=40,
        filter_corners=4,
        start_pad=start_pad,
        adj_src_type="cc", 

        # vvvv IMPORTANT PyFlex windowing parameters vvvv
        stalta_waterlevel=stalta_waterlevel,
        tshift_acceptance_level=12.0, 
        dlna_acceptance_level=2.5, 
        cc_acceptance_level=0.7, 
        s2n_limit=1, 
        min_surface_wave_velocity=1.0,
        max_time_before_first_arrival=5,
        snr_integrate_base=3.5,
        c_0=0.7, 
        c_1=2.0, 
        c_3a=1.0, 
        c_3b=2.0, 
        c_4a=3.0, 
        c_4b=10.0,
        check_global_data_quality=False, 

        # vvvv Less important PyFlex windowing parameters vvvv
        c_2=0.0,
        tshift_reference=0.0,
        dlna_reference=0.0,
        earth_model="ak135",
        snr_max_base=3.0, 
        noise_start_index=0, 
        noise_end_index=None,
        signal_start_index=None, 
        signal_end_index=-1,
        window_weight_fct=None,
        window_signal_to_noise_type="amplitude",
        resolution_strategy="interval_scheduling"
        )

# >>> Kludge Pyflex to have longer window lengths
cfg.pyflex_config.min_period = 10

f = open("missing_stations.txt", "w")

# >>> Run Pyatoa processing
print("running Pyatoa")

# >>> Trying to get NET.STA for all synthetic data
station_codes = glob(os.path.join(path_to_synthetics, "*.semd"))
station_codes = [os.path.basename(_) for _ in station_codes]
station_codes = [f"{_.split('.')[0]}.{_.split('.')[1]}" for _ in station_codes]

for station_code in set(sorted(station_codes)):
    print(f"\t{station_code}")
    net, sta = station_code.split(".")
    # Read in sythetics
    st_syn = Stream()
    for syn_fid in glob(os.path.join(path_to_synthetics, 
                                     f"{net}.{sta}.???.semd")):
        st_syn += read_sem(syn_fid, origintime=origintime)

    # Find matching data
    # Build ID manually to match PySEP output naming. Wildcard for generality
    st_fid_wildcard = f"{cfg.event_id}.{net}.{sta}.*.??[ZNE].sac"
    st_path_wildcard = os.path.join(path_to_data, st_fid_wildcard)
    st_paths = glob(st_path_wildcard)
  
    # If no matching data found to compare against synthetics, skip over
    if not st_paths:
        f.write(f"NODATA: {station_code}\n")
        continue

    # Read in observation data 
    st_obs = Stream()
    for st_path in st_paths:
        st_obs += read(st_path)

    # Run processing/windowing
    try:
        # # Kludge delete sac header so that Pyflex doesnt read them for metadata
        # for tr in st_obs:
        #     if hasattr(tr.stats, "sac"):
        #         del tr.stats.sac
        # for tr in st_syn:
        #     if hasattr(tr.stats, "sac"):
        #         del tr.stats.sac
           
        # Run generalized processing and windowing
        mgmt = Manager(config=cfg, st_obs=st_obs, st_syn=st_syn, event=event)
        mgmt.standardize()

        # Preprocess and zero pad data by 1/3 trace length
        zero_pad_samp = len(mgmt.st_obs[0].data) // 3 
        zero_pad_s = zero_pad_samp * mgmt.st_obs[0].stats.delta
        mgmt.preprocess(zero_pad_s=zero_pad_s)

        # Manually construct water-level to mask out parts of the waveform
        samp_rate = mgmt.st_obs[0].stats.sampling_rate
        wl_arr = np.ones(len(mgmt.st_obs[0].data))  # waterlevel_array
        start = int(start_pad * samp_rate)  # start pad defines origin time, kludge
        end = int(end_wl * samp_rate)  # cutoff 150s after origin time
        wl_arr[start:end] *= stalta_waterlevel
        mgmt.config.pyflex_config.stalta_waterlevel = wl_arr

        mgmt.window()
        mgmt.measure()

        # Plot figure
        fig_id = os.path.join(path_to_figures, f"{station_code}.png")
        mgmt.plot(choice="wav", show=False, save=fig_id,
                  xlim_s=[-50, 200])
        plt.close("all")

        # Kludge - Cut the adjoint sources manually based on the known zero
        # pad that we added to the traces
        for comp, adjsrc in mgmt.adjsrcs.items():
            n = len(adjsrc.adjoint_source)
            new_adjsrc = adjsrc.adjoint_source[zero_pad_samp:n-zero_pad_samp]
            assert(len(new_adjsrc) == len(st_syn[0].data))
            mgmt.adjsrcs[comp].adjoint_source = new_adjsrc
            
        # Write adjoint sources
        mgmt.write_adjsrcs(path=path_to_adjsrcs)
    except Exception as e:
        import traceback
        f.write(f"FAIL: {station_code}\n")
        traceback.print_exc()
        continue

f.close()
